## 44. Виртуальное наследование
* ## Виртуальный базовый класс: синтаксис, пример, проблема ромба

Это [Вторая половина лекции 13](https://youtu.be/mkNxIN5caf4)

Опишем ситуацию: пусть у нас есть люди с именами, люди бывают работниками в какой-то компании, а еще бывают студентами в какой-то группе. А есть магические студенты: и учатся, и работают:

```
Person   Person
   ^        ^
   |        |
Employee Student
   ^        ^
    \      /
     \    /
  MagicStudent
```

Проблема: Если мы хотим получить им у магического студента имя, то мы проиграем. У нас есть имя у работника и у студента. Что... Странно.

Соответственно мы хотим следующее:

```
      Person
       ^  ^
      /    \
     /      \
 Employee Student
    ^        ^
     \      /
      \    /
   MagicStudent
```

И вот уже эта штука и есть проблема ромба.

Если мы вот так вот хотим отнаследователься от `Person`, то тут уже начинается виртуальное наследование, мы должны указать наследование от `Person` как `virtual`:

```c++
struct Person {
    std::string name;
    Person(std::string name_) : name(std::move(name_)) {
        std::cout << "Person(" << name << ")\n";
    }
};
struct Employee : virtual /* !!! */ Person {
    std::string employer;
    Employee(std::string name_, std::string employer_) : Person(std::move(name_)), employer(std::move(employer_)) {}
};
struct Student : virtual /* !!! */ Person {
    std::string group;
    Student(std::string name_, std::string group_) : Person(std::move(name_)), group(std::move(group_)) {}
};
struct MagicStudent : Employee, Student {
    MagicStudent(std::string name_, std::string employer_, std::string group_)
        : Person(std::move(name_))
        , Employee("", std::move(employer_))
        , Student("", std::move(group_)) {}  // TODO: we still have to provide fake 'name', even though Person() is not really called.
};
```

* ## Порядок инициализации/уничтожения подобъектов и полей, как и где передать параметры конструктором

Сначала создаются все виртуальные, в порядке от базы к наследникам, затем остальное.

А уничтожение происходит в обратном порядке, вроде как, как и всегда.

А про параметры конструктором вообще не понял, в чём отличие от того, что описано пунктом выше? Сначала строим базовый виртуальный класс, его дальше передаём в конструкторы классов-предков. 

* ## Возможное представление в памяти (только для неполиморфных классов)

Если я правильно понял, что подразумевает, то вот варианты:

```
0                 8            40             48       80           112
+-----------------------------------------------------------------+
|  +------------------------+  +---------------------+ +--------+ |
|  | +---------+            |  | +---------+         | | Person | |
|  | | PersonV |            |  | | PersonV |         | | +name  | |
|  | | +person |            |  | | +person |         | +--------+ |
|  | +---------+            |  | +---------+         |            |
|  | Employee'              |  | Student'            |            |
|  |              +employer |  |              +group |            |
|  +------------------------+  +---------------------+            |
| MagicStudent                                                    |
+-----------------------------------------------------------------+
or:
0                 8        40           72
+-------------------------------------+
|  +---------------------+ +--------+ |
|  | +---------+         | | Person | |
|  | | PersonV |         | | +name  | |
|  | | +person |         | +--------+ |
|  | +---------+         |            |
|  | Student'            |            |
|  |              +group |            |
|  +---------------------+            |
| Student                             |
+-------------------------------------+
```
  * ### Необходимость хранения указателя в каждой виртуальной базе  
  
  Если тут вообще про то, как это реализовано -- **EPIC FAIL**
  
  Извините, не понял. Это, видимо, не про то, что указатели могут быть относительными.
  
  ==хб помоги==
* ## Что происходит, если один класс объявляется и виртуальным, и невиртуальным

Пусть есть 

```c++
struct Base { int data = 0; };
struct X : virtual Base {};
struct Y : virtual Base {};
struct Z : Base {};
struct Derived : X, Y, Z {};
```

В такой ситуации у нас будет два экземпляра `Base` - один виртуальный для `X` и `Y` и по одному не-виртуальному на остальные.

Как итог получили два `Base` со всеми вытекающими (неопределённое обращение).

Итог: Для каждой базы B: не более одного виртуального B, произвольное число невиртуальных.

* ## Взаимодействие с `dynamic_cast` при наличии виртуальных методов (работает) и их отсутствии (невозможно)
    ==Иии что тут сказать?== Без виртуальных методов `dynamic_cast` никогда не работает.

* ## Delegate-to-sister

```c++
struct Base {
    virtual void foo() = 0;
    virtual void bar() = 0;
};

struct X : virtual Base {
    void foo() override {
        std::cout << "X::foo()\n";
        bar();  // // https://isocpp.org/wiki/faq/multiple-inheritance#mi-delegate-to-sister
    }
};

struct Y : virtual Base {
    void bar() override {
        std::cout << "Y::bar()\n";
    }
};

struct Derived : X, Y {
};

a.foo();  // X::foo() --> Base::bar() ~~ Y::bar()
```

`X` поднимается к `Base`, спускается в `Y` и вызывается `bar` ==???==

* ## Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding/приватное и защищённое наследование
Статик даун каст не работает при касте к ссылке нашего класса из виртуального отца, потому что на самом деле мы не знаем offset'ы.

Тогда для этого нужно делать `dynamic_cast`. Но для этого нужна полиморфность.

О публичном/приватном наследовании:

```c++
struct Base {
    int data;
};

struct X : private virtual Base {
};

struct Y : public virtual Base {
};
struct X1 : X {
    void foo() {
        // data = 10;  // access through X, private
    }
};

struct Derived : X, Y {
    void foo() {
        data = 10;  // access is public through Y
    }
};  
```

Заметим, что в X1 у нас data приватная. А вот в Derived у нас выбирает самый легкодоступная ветвь для доступа.
 
  * ### В том числе при наличии одинаковых виртуальных функций в независимых базах  
  
  ==Возможно== Насколько я помню, если мы не переопределили в итоговом наследнике, то мы закончим существование с несколькими реализациями функции, и, в общем, `ambiguous`
  
  Если мы переопределили, то у них должны быть одинаковые сигнатуры (НЕ УВЕРЕН), а если одинаковые -- то просто переопределили и всё круто.

Тесно связано с: множественное наследование
